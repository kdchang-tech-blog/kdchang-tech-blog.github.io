---
title: JavaScript 練習挑戰紀錄 | 學習筆記
date: 2018-02-02 02:23:41
author: kdchang
tags: 
    - JavaScript
    - coding

---

## Longest Word
當我們執行 `paragraph.match(/[a-z]+/gi)` 時，這段 JavaScript 程式碼的意思是：

### **目的：**
從 `paragraph` 字串中**找出所有連續的英文字母（不分大小寫）組成的片段**，並以陣列形式回傳。

---

### **語法拆解：**

```js
paragraph.match(/[a-z]+/gi)
```

| 部分             | 意思                                                                 |
|------------------|----------------------------------------------------------------------|
| `paragraph`      | 要處理的字串（變數名）                                                |
| `.match(...)`    | 是一個字串的方法，會根據正則表達式去**尋找所有符合條件的子字串**             |
| `/[a-z]+/gi`     | 正則表達式：搜尋一或多個英文字母                                       |
| `[a-z]`          | 表示小寫英文字母 a 到 z（大寫會由 `i` 修飾符處理）                      |
| `+`              | 表示「一個或多個」符合前面 `[a-z]` 的字元                                 |
| `g`              | global 全域搜尋，找到**所有符合條件**的片段                             |
| `i`              | ignore case 忽略大小寫，讓 `[a-z]` 同時能配對 `A-Z`                     |

---

### **範例：**

```js
const paragraph = "Hello, 世界! This is a test123.";
const result = paragraph.match(/[a-z]+/gi);
console.log(result);
```

#### 輸出：
```
["Hello", "This", "is", "a", "test"]
```

這段程式會：
- 忽略中文與數字
- 把英文字母串（不論大小寫）全都抓出來


好，我們真的慢慢來，我會用**超直白的說法、一步一步演示**，幫你理解 `arr.sort((a, b) => a - b)` 是怎麼把數字從小排到大的。

---

## 先記住一個核心概念：

```js
arr.sort((a, b) => a - b);
```

這一行的意思是：

> 陣列裡的「每兩個數字 a 和 b」，如果 a 比 b 小，就讓 a 排在 b 前面。

---

## 一步一步來看：

假設這個陣列：

```js
let arr = [30, 10, 5];
```

我們要用 `sort()` 排成：
```
[5, 10, 30]
```

---

## JS 怎麼做的？

它會自動幫你「兩個兩個配對」來比較順序。

### 第一次比較：30 和 10
```js
a = 30, b = 10
a - b = 30 - 10 = 20（是正數）

JavaScript 覺得：b（10）比較小 → 讓 10 排在 30 前面
```

結果變成這樣：
```
[10, 30, 5]
```

---

### 第二次比較：30 和 5
```js
a = 30, b = 5
a - b = 30 - 5 = 25（是正數）

b（5）比較小 → 把 5 放到前面
```

結果變成：
```
[10, 5, 30]
```

---

### 第三次比較：10 和 5
```js
a = 10, b = 5
a - b = 10 - 5 = 5（是正數）

b（5）比較小 → 把 5 放到前面
```

最後得到：
```
[5, 10, 30]
```

就是我們想要的「從小到大」排序！

---

## 最簡單的記法：

| 語法 | 排序方式 |
|------|----------|
| `(a, b) => a - b` | 小到大 |
| `(a, b) => b - a` | 大到小 |

---

## 小挑戰

```js
let arr = [8, 3, 100, 1];
arr.sort((a, b) => a - b); // [1, 3, 8, 100]
```

# Codeland Username Validation

符合條件的正則表達式：

### 正則表達式：
```regex
^[A-Za-z][A-Za-z0-9_]{2,23}[A-Za-z0-9]$
```

### 解釋：
1. **`^`**：字串的開始。
2. **`[A-Za-z]`**：第一個字符必須是字母（無論是大寫還是小寫）。
3. **`[A-Za-z0-9_]{2,23}`**：接下來可以包含字母、數字或底線，並且長度必須在 2 到 23 之間。這確保了整個字串的長度在 4 到 25 之間（包括起始的字母）。
4. **`[A-Za-z0-9]`**：字串的結尾必須是字母或數字，不能是底線 `_`。
5. **`$`**：字串的結束。

### 規則解釋：
1. 用戶名必須是 4 到 25 個字符。
2. 用戶名的開頭必須是字母。
3. 用戶名可以包含字母、數字和底線 `_`。
4. 用戶名不能以底線 `_` 結尾。

### 範例：
- `"username123"` 會匹配成功。
- `"user_name"` 會匹配成功。
- `"user_name_"` 會匹配失敗（因為底線 `_` 在結尾）。
- `"123username"` 會匹配失敗（因為開頭不是字母）。
- `"user"` 會匹配成功。
- `"a_1"` 會匹配失敗（因為長度太短，少於 4 個字符）。


## 2620. Counter

```js
var createCounter = function(n) {
    return function() {
        return n++;
    };
};
```

這樣做的好處是：

n 是外部函式的區域變數（`closure`）

每次呼叫內部函式都能使用並修改 n

n++ 會先回傳 n 的值，再讓 n 加 1


小補充：n++ vs ++n
n++：先回傳，再加一
++n：先加一，再回傳